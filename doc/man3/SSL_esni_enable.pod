=pod

=head1 NAME

SSL_esni_enable, SSL_ESNI_new_from_buffer,
SSL_esni_checknames, SSL_get_esni_status, 
SSL_ESNI_print, SSL_ESNI_free,
SSL_set_esni_callback, 
SSL_SESSION_set1_enchostname, SSL_SESSION_set1_covername,
SSL_SESSION_set1_public_name, SSL_SESSION_get0_enchostname
- Encrypted Server Name Indication (ESNI) support - client and common functions 

=head1 SYNOPSIS

 #include <openssl/esni.h>
 int SSL_esni_enable(SSL *s, const char *hidden, const char *cover, SSL_ESNI *esni, int nesnis, int require_hidden_match);
 SSL_ESNI* SSL_ESNI_new_from_buffer(const short ekfmt, const size_t eklen, const char *esnikeys, int *num_esnis);
 int SSL_esni_checknames(const char *encservername, const char *covername);
 int SSL_get_esni_status(SSL *s, char **hidden, char **cover);
 int SSL_ESNI_print(BIO* out, SSL_ESNI *esni, int selector);
 void SSL_ESNI_free(SSL_ESNI *esnikeys);
 void SSL_set_esni_callback(SSL *s, SSL_esni_client_cb_func f);
 int SSL_SESSION_set1_enchostname(SSL_SESSION *s, const char *hostname);
 int SSL_SESSION_set1_covername(SSL_SESSION *s, const char *covername);
 int SSL_SESSION_set1_public_name(SSL_SESSION *s, const char *public_name);
 const char *SSL_SESSION_get0_enchostname(const SSL_SESSION *s);

=head1 DESCRIPTION

These functions handle the client side of encrypted SNI. Some are also used on
servers.

SSL_esni_enable() requests that ESNI be used for a TLS session, with the
specified ``hidden`` name and an optional ``cover`` name that will be sent in
the cleartext SNI. (If no cleartext SNI is desired, provide a NULL.) 

SSL_esni_enable() also takes as input an array of SSL_ESNI structures that was
output from SSL_ESNI_new_from_buffer(), the size of that array, and a flag
determining if the hidden name needs to match the TLS server certificate used
in the handshake or not. (That last may disappear.)

SSL_ESNI_new_from_buffer() takes as input a buffer containing a set of encoded
ESNIKeys, typically retrieved from DNS, checks and parses that buffer into an
array of SSL_ESNI structures that can subsequently be used in
SSL_esni_enable(). The size of that array is also returned in ``num_esnis``.

SSL_ESNI_new_from_buffer() also takes a format type as input.  That can take
the following values: 
- ESNI_RRFMT_GUESS: the implementation will try guess the format
- ESNI_RRFMT_BIN: the buffer contains binary encoded ESNIKeys
- ESNI_RRFMT_ASCIIHEX: the buffer contains ascii hex ESNIKeys
- ESNI_RRFMT_B64TXT: the buffer contains  base64 encoded ESNIKeys

In each case, the buffer can contain a set of catenated ESNIKeys values. (For
the base64 encoded option, those need to be separated by a semi-colon.)

SSL_esni_checknames() currently only checks that the hidden and cover
names are not the same, which would be undesirable. (This may 
disappear.) 

SSL_esni_get_status() will return the status of ESNI for an SSL session,
post-handshake. If ESNI was used the ``hidden`` and ``cover`` values will be
set appropriately. (If no cleartext SNI was used in the handshake, the
``cover`` returned will be a NULL.) The return value can be one of:
- SSL_ESNI_STATUS_GREASE - ESNI GREASE happened (if you care:-)
- SSL_ESNI_STATUS_SUCCESS - Success
- SSL_ESNI_STATUS_FAILED  - Some internal error
- SSL_ESNI_STATUS_BAD_CALL  - Required in/out arguments were badly set
- SSL_ESNI_STATUS_NOT_TRIED  - ESNI wasn't attempted 
- SSL_ESNI_STATUS_BAD_NAME  - ESNI succeeded but the server cert didn't match
                              the hidden service name
- SSL_ESNI_STATUS_TOOMANY  - ESNI succeeded but we can't figure out which one!

Still TBD:
SSL_ESNI_print()
SSL_ESNI_free()
SSL_set_esni_callback()
SSL_SESSION_set1_enchostname()
SSL_SESSION_set1_covername()
SSL_SESSION_set1_public_name()
SSL_SESSION_get0_enchostname()

=head1 RETURN VALUES

Unless otherwise stated all functions return 1 for success.

=head1 SEE ALSO

The specification: https://tools.ietf.org/html/draft-ietf-tls-esni

My fork has a bit of a design doc: https://github.com/sftcd/openssl/blob/master/esnistuff/design.md

=head1 HISTORY

Initially developed by Stephen Farrell. Subsequently supported by OTF via
the DEfO project: https://defo.ie/

=head1 COPYRIGHT

Copyright 2002-2019 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the Apache License 2.0 (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
